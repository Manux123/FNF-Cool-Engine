package mods.compat;

using StringTools;

/**
 * LuaStageConverter
 * ─────────────────────────────────────────────────────────────────────────────
 * Transpiles a Psych Engine stage .lua script to HScript-compatible .hx code.
 *
 * Handles the most common Psych stage Lua patterns:
 *   - Block structure (if/elseif/else/end, function/end, for/end, while/end)
 *   - Lua comments (-- → //)
 *   - Lua operators (~=, and, or, not, ..)
 *   - Local variables (local x = → var x =)
 *   - Psych API calls (passed through — exposed by PsychLuaStageAPI)
 *   - Conditional function definitions (if cond then function name() end end)
 *   - Known callback injection (onStepHit, onBeatHit get their args)
 *
 * Limitations (intentional — Lua features not used in stage scripts):
 *   - No Lua tables, metatables, or OOP
 *   - No varargs (...)
 *   - No pcall/xpcall
 *   - No require/module system
 *   - Multiline strings not supported
 */
class LuaStageConverter
{
	// Block types tracked in the stack
	static inline var BLK_IF       = 'if';
	static inline var BLK_FUNCTION = 'function';
	static inline var BLK_FOR      = 'for';
	static inline var BLK_WHILE    = 'while';
	static inline var BLK_DO       = 'do';
	static inline var BLK_REPEAT   = 'repeat';

	// Known callbacks that need argument injection
	static var CALLBACK_ARGS:Map<String, String> = [
		'onStepHit'  => 'curStep:Int',
		'onBeatHit'  => 'curBeat:Int',
		'onUpdate'   => 'elapsed:Float',
		'onUpdatePost' => 'elapsed:Float',
		'onNoteHit'  => 'note:Dynamic',
		'onNoteMiss' => 'note:Dynamic',
	];

	// ─── Public API ───────────────────────────────────────────────────────────

	/**
	 * Converts a raw Psych Lua script string to HScript code.
	 * @param luaCode   Raw content of the .lua file.
	 * @param scriptName  Used in the header comment only.
	 */
	public static function convert(luaCode:String, scriptName:String):String
	{
		final lines  = luaCode.replace('\r\n', '\n').replace('\r', '\n').split('\n');
		final output = new Array<String>();

		output.push('// Auto-transpiled from Lua: $scriptName.lua');
		output.push('// Generated by LuaStageConverter — do not edit manually.');
		output.push('');

		final ctx = new ConvCtx();

		for (rawLine in lines)
		{
			final result = _processLine(rawLine, ctx);
			for (outLine in result)
				output.push(outLine);
		}

		// Close any unclosed blocks (shouldn't happen in valid Lua, but safety net)
		while (ctx.stack.length > 0)
		{
			ctx.stack.pop();
			output.push('}');
		}

		return output.join('\n');
	}

	// ─── Internal ─────────────────────────────────────────────────────────────

	static function _processLine(rawLine:String, ctx:ConvCtx):Array<String>
	{
		// Preserve blank lines
		final trimmed = rawLine.trim();
		if (trimmed == '')
			return [''];

		// Extract leading indent
		var i = 0;
		while (i < rawLine.length && (rawLine.charAt(i) == ' ' || rawLine.charAt(i) == '\t'))
			i++;
		final indent = rawLine.substr(0, i);

		// ── Comments ──────────────────────────────────────────────────────────
		if (trimmed.startsWith('--'))
			return [indent + '//' + trimmed.substr(2)];

		// ── until (end of repeat block) ───────────────────────────────────────
		if (trimmed.startsWith('until ') || trimmed == 'until')
		{
			if (ctx.stack.length > 0) ctx.stack.pop();
			final cond = trimmed.substr(6).trim();
			return [indent + '} while (!(' + _expr(cond) + '));'];
		}

		// ── repeat ────────────────────────────────────────────────────────────
		if (trimmed == 'repeat')
		{
			ctx.stack.push(BLK_REPEAT);
			return [indent + 'do {'];
		}

		// ── end ───────────────────────────────────────────────────────────────
		if (trimmed == 'end' || trimmed == 'end;')
		{
			final blkType = ctx.stack.length > 0 ? ctx.stack.pop() : BLK_DO;
			// Add semicolon after closing a function assigned as variable
			final semi = (blkType == BLK_FUNCTION && ctx.lastFuncWasVar) ? ';' : '';
			return [indent + '}' + semi];
		}

		// ── elseif ────────────────────────────────────────────────────────────
		if (trimmed.startsWith('elseif '))
		{
			// Pop the IF block, then push a new one
			if (ctx.stack.length > 0 && ctx.stack[ctx.stack.length - 1] == BLK_IF)
				ctx.stack.pop();
			ctx.stack.push(BLK_IF);
			final cond = _extractIfCond(trimmed.substr(7));
			return [indent + '} else if (' + cond + ') {'];
		}

		// ── else ──────────────────────────────────────────────────────────────
		if (trimmed == 'else')
			return [indent + '} else {'];

		// ── if ────────────────────────────────────────────────────────────────
		if (trimmed.startsWith('if '))
		{
			ctx.stack.push(BLK_IF);
			final rest   = trimmed.substr(3);
			final cond   = _extractIfCond(rest);

			// Detect inline: "if cond then stmt end"
			final afterThen = _afterThen(rest);
			if (afterThen != null && afterThen.endsWith('end'))
			{
				// Single-line if: if cond then stmt end → if (cond) { stmt }
				ctx.stack.pop();
				final body = afterThen.substr(0, afterThen.length - 3).trim();
				return [indent + 'if (' + cond + ') {',
				        indent + '\t' + _stmt(body, ctx),
				        indent + '}'];
			}

			return [indent + 'if (' + cond + ') {'];
		}

		// ── for ───────────────────────────────────────────────────────────────
		if (trimmed.startsWith('for '))
		{
			ctx.stack.push(BLK_FOR);
			return [indent + _convertFor(trimmed) + ' {'];
		}

		// ── while ─────────────────────────────────────────────────────────────
		if (trimmed.startsWith('while '))
		{
			ctx.stack.push(BLK_WHILE);
			final cond = _extractIfCond(trimmed.substr(6));
			return [indent + 'while (' + cond + ') {'];
		}

		// ── do ────────────────────────────────────────────────────────────────
		if (trimmed == 'do')
		{
			ctx.stack.push(BLK_DO);
			return [indent + '{'];
		}

		// ── function ──────────────────────────────────────────────────────────
		if (trimmed.startsWith('function '))
		{
			ctx.stack.push(BLK_FUNCTION);
			return [indent + _convertFunction(trimmed, ctx)];
		}

		// ── local function ────────────────────────────────────────────────────
		if (trimmed.startsWith('local function '))
		{
			ctx.stack.push(BLK_FUNCTION);
			ctx.lastFuncWasVar = true;
			return [indent + _convertFunction('function ' + trimmed.substr(15), ctx)];
		}

		// ── return ────────────────────────────────────────────────────────────
		if (trimmed.startsWith('return'))
		{
			final val = trimmed.substr(6).trim();
			return [indent + 'return' + (val != '' ? ' ' + _expr(val) : '') + ';'];
		}

		// ── regular statement / expression ────────────────────────────────────
		return [indent + _stmt(trimmed, ctx)];
	}

	// ── Function conversion ───────────────────────────────────────────────────

	static function _convertFunction(trimmed:String, ctx:ConvCtx):String
	{
		// Parse: function name(args)
		final pOpen  = trimmed.indexOf('(');
		final pClose = trimmed.lastIndexOf(')');

		if (pOpen < 0)
			return trimmed + ' {'; // malformed, pass through

		final namePart = trimmed.substr(9, pOpen - 9).trim(); // after "function "
		final rawArgs  = pClose > pOpen ? trimmed.substr(pOpen + 1, pClose - pOpen - 1).trim() : '';

		// Inject known callback args if Lua defined them without params
		var args = rawArgs;
		if (CALLBACK_ARGS.exists(namePart) && rawArgs == '')
			args = CALLBACK_ARGS.get(namePart);

		// Detect if we're inside an if block → conditional function definition
		// Convert to variable assignment so the if gate is respected at runtime
		final isInsideBlock = ctx.stack.length >= 2; // at least one outer block
		if (isInsideBlock)
		{
			ctx.lastFuncWasVar = true;
			return '$namePart = function($args) {';
		}

		ctx.lastFuncWasVar = false;
		return 'function $namePart($args) {';
	}

	// ── For loop conversion ───────────────────────────────────────────────────

	static function _convertFor(trimmed:String):String
	{
		// "for i = 1, 10 do" → "for (i in 1...11)"   (numeric)
		// "for i = 1, 10, 2 do" → manual while (step != 1)
		// "for k, v in pairs(t) do" → "for k => v in t"  (generic, approx)
		final rest = trimmed.substr(4).trim();
		final doIdx = rest.lastIndexOf(' do');
		final body  = doIdx >= 0 ? rest.substr(0, doIdx).trim() : rest.trim();

		// Numeric: "i = start, end" or "i = start, end, step"
		final eqIdx = body.indexOf('=');
		if (eqIdx >= 0)
		{
			final varName = body.substr(0, eqIdx).trim();
			final parts   = body.substr(eqIdx + 1).split(',').map(s -> s.trim());
			if (parts.length >= 2)
			{
				final start = _expr(parts[0]);
				final stop  = _expr(parts[1]);
				if (parts.length == 2)
					return 'for ($varName in $start...($stop + 1))';
				// With step — use while loop approximation
				final step = _expr(parts[2]);
				return '{ var $varName = $start; while ($varName <= $stop) { $varName += $step; }';
			}
		}

		// Generic pairs/ipairs: "k, v in pairs(t)"
		final inIdx = body.indexOf(' in ');
		if (inIdx >= 0)
		{
			final vars  = body.substr(0, inIdx).trim();
			var iter = body.substr(inIdx + 4).trim();
			// Strip pairs()/ipairs() wrapper
			if (iter.startsWith('pairs(') || iter.startsWith('ipairs('))
				iter = iter.substr(iter.indexOf('(') + 1, iter.lastIndexOf(')') - iter.indexOf('(') - 1);
			return 'for ($vars in $iter)';
		}

		return 'for ($body)'; // fallback
	}

	// ── Expression converter ──────────────────────────────────────────────────

	static function _expr(e:String):String
	{
		if (e == null || e == '')
			return e;

		e = _convertStringConcat(e);
		e = _replaceOutside(e, ' and ', ' && ');
		e = _replaceOutside(e, ' or ',  ' || ');
		e = _replaceOutside(e, '~=',    '!=');
		e = _replaceOutside(e, ' not ', ' !');
		// "not x" at start of expression
		if (e.startsWith('not '))
			e = '!' + e.substr(4);
		e = e.replace('nil', 'null');
		return e;
	}

	// Converts Lua string concatenation (..) to HScript (+), skipping string literals
	static function _convertStringConcat(e:String):String
	{
		final buf = new StringBuf();
		var i     = 0;
		final len = e.length;

		while (i < len)
		{
			final ch = e.charAt(i);

			// Skip string literals
			if (ch == '"' || ch == "'")
			{
				final q = ch;
				buf.add(ch);
				i++;
				while (i < len)
				{
					final c2 = e.charAt(i);
					buf.add(c2);
					i++;
					if (c2 == '\\') { buf.add(e.charAt(i)); i++; continue; }
					if (c2 == q)     break;
				}
				continue;
			}

			// Check for ".." but not "..."
			if (ch == '.' && i + 1 < len && e.charAt(i + 1) == '.' && (i + 2 >= len || e.charAt(i + 2) != '.'))
			{
				buf.add(' + ');
				i += 2;
				continue;
			}

			buf.add(ch);
			i++;
		}

		return buf.toString();
	}

	// Replace a substring outside string literals
	static function _replaceOutside(e:String, from:String, to:String):String
	{
		final buf = new StringBuf();
		var i     = 0;
		final len = e.length;
		final fl  = from.length;

		while (i < len)
		{
			final ch = e.charAt(i);

			if (ch == '"' || ch == "'")
			{
				final q = ch;
				buf.add(ch); i++;
				while (i < len)
				{
					final c2 = e.charAt(i);
					buf.add(c2); i++;
					if (c2 == '\\') { buf.add(e.charAt(i)); i++; continue; }
					if (c2 == q)    break;
				}
				continue;
			}

			if (i + fl <= len && e.substr(i, fl) == from)
			{
				buf.add(to);
				i += fl;
				continue;
			}

			buf.add(ch);
			i++;
		}

		return buf.toString();
	}

	// ── Statement converter ───────────────────────────────────────────────────

	static function _stmt(line:String, ctx:ConvCtx):String
	{
		// Strip inline Lua comment
		final commentIdx = _findInlineComment(line);
		var stmt = commentIdx >= 0 ? line.substr(0, commentIdx).rtrim() : line;
		var comment = commentIdx >= 0 ? '  //' + line.substr(commentIdx + 2) : '';

		// local variable
		if (stmt.startsWith('local '))
			stmt = 'var ' + stmt.substr(6);

		// Convert expression
		stmt = _expr(stmt);

		// Add semicolon if not already there and not a block opener
		if (!stmt.endsWith(';') && !stmt.endsWith('{') && !stmt.endsWith('}'))
			stmt += ';';

		return stmt + comment;
	}

	// ── If condition helpers ──────────────────────────────────────────────────

	// Extracts the condition from "cond then ..." → "cond"
	static function _extractIfCond(rest:String):String
	{
		// Find " then" outside strings
		var depth = 0;
		var i     = 0;
		final len = rest.length;

		while (i < len)
		{
			final ch = rest.charAt(i);
			if (ch == '"' || ch == "'")
			{
				final q = ch; i++;
				while (i < len) { final c2 = rest.charAt(i); i++; if (c2 == '\\') i++; else if (c2 == q) break; }
				continue;
			}
			if (ch == '(') { depth++; i++; continue; }
			if (ch == ')') { depth--; i++; continue; }
			if (depth == 0 && rest.substr(i, 5) == ' then')
				return _expr(rest.substr(0, i).trim());
			i++;
		}
		// No "then" found — return everything
		return _expr(rest.replace(' then', '').trim());
	}

	// Returns the part after "then" on the same line, or null if nothing / only whitespace
	static function _afterThen(rest:String):Null<String>
	{
		final idx = rest.indexOf(' then');
		if (idx < 0) return null;
		final after = rest.substr(idx + 5).trim();
		return after == '' ? null : after;
	}

	// Finds the index of an inline "--" comment outside strings. Returns -1 if none.
	static function _findInlineComment(line:String):Int
	{
		var i = 0;
		final len = line.length;
		while (i < len)
		{
			final ch = line.charAt(i);
			if (ch == '"' || ch == "'")
			{
				final q = ch; i++;
				while (i < len) { final c2 = line.charAt(i); i++; if (c2 == '\\') i++; else if (c2 == q) break; }
				continue;
			}
			if (i + 1 < len && ch == '-' && line.charAt(i + 1) == '-')
				return i;
			i++;
		}
		return -1;
	}
}

// ─── Conversion context ───────────────────────────────────────────────────────

/** Mutable state threaded through the conversion. */
private class ConvCtx
{
	public var stack:Array<String>;
	public var lastFuncWasVar:Bool;

	public function new()
	{
		stack          = [];
		lastFuncWasVar = false;
	}
}
